# -*- coding: utf-8 -*-
"""cf_model_fixed.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_EAz-u9dDeGBQ5eYtQxUfKylOEx80J5y
"""





# -*- coding: utf-8 -*-
"""
FIX: Collaborative Filtering - Save similarity matrices separately
"""

import numpy as np
import pandas as pd
import pickle
from sklearn.metrics.pairwise import cosine_similarity

print("\n" + "="*60)
print("FIXING COLLABORATIVE FILTERING MODEL")
print("="*60)

# Load user-item matrix
print("Loading user-item matrix...")
with open('/content/drive/MyDrive/Recommendation/requirements/train_matrix.pkl', 'rb') as f:
    train_matrix = pickle.load(f)
print(f"✓ Loaded matrix of shape {train_matrix.shape}")

class CollaborativeFiltering:
    """Collaborative Filtering Recommender"""

    def __init__(self, user_item_matrix):
        self.user_item_matrix = user_item_matrix
        self.user_similarity = None
        self.item_similarity = None
        self.global_mean = user_item_matrix[user_item_matrix > 0].mean().mean()
        print(f"Global mean rating: {self.global_mean:.2f}")

    def compute_user_similarity(self):
        """Compute user-user similarity matrix"""
        print("\nComputing user-user similarity matrix...")
        matrix_filled = self.user_item_matrix.replace(0, np.nan).fillna(self.global_mean)
        self.user_similarity = cosine_similarity(matrix_filled)
        print(f"✓ User similarity matrix shape: {self.user_similarity.shape}")
        return self.user_similarity

    def compute_item_similarity(self):
        """Compute item-item similarity matrix"""
        print("Computing item-item similarity matrix...")
        matrix_filled = self.user_item_matrix.replace(0, np.nan).fillna(self.global_mean)
        self.item_similarity = cosine_similarity(matrix_filled.T)
        print(f"✓ Item similarity matrix shape: {self.item_similarity.shape}")
        return self.item_similarity

    def predict_user_based(self, user_id, movie_id, k=20):
        """User-based CF prediction"""
        try:
            # Check if matrices are loaded
            if self.user_similarity is None:
                print("⚠️  User similarity matrix not loaded!")
                return self.global_mean

            if user_id not in self.user_item_matrix.index:
                return self.global_mean
            if movie_id not in self.user_item_matrix.columns:
                return self.global_mean

            user_idx = self.user_item_matrix.index.get_loc(user_id)
            movie_idx = self.user_item_matrix.columns.get_loc(movie_id)

            # Get similarity scores
            sim_scores = self.user_similarity[user_idx]

            # Get k most similar users
            similar_user_indices = np.argsort(sim_scores)[::-1][1:k+1]

            ratings = []
            weights = []

            for idx in similar_user_indices:
                rating = self.user_item_matrix.iloc[idx, movie_idx]
                if rating > 0:
                    ratings.append(rating)
                    weights.append(sim_scores[idx])

            if len(ratings) == 0 or sum(weights) == 0:
                return self.global_mean

            return np.average(ratings, weights=weights)

        except Exception as e:
            print(f"CF User-based error: {e}")
            return self.global_mean

    def predict_item_based(self, user_id, movie_id, k=20):
        """Item-based CF prediction"""
        try:
            # Check if matrices are loaded
            if self.item_similarity is None:
                print("⚠️  Item similarity matrix not loaded!")
                return self.global_mean

            if user_id not in self.user_item_matrix.index:
                return self.global_mean
            if movie_id not in self.user_item_matrix.columns:
                return self.global_mean

            user_idx = self.user_item_matrix.index.get_loc(user_id)
            movie_idx = self.user_item_matrix.columns.get_loc(movie_id)

            # Get similarity scores
            sim_scores = self.item_similarity[movie_idx]

            # Get k most similar items
            similar_item_indices = np.argsort(sim_scores)[::-1][1:k+1]

            ratings = []
            weights = []

            for idx in similar_item_indices:
                rating = self.user_item_matrix.iloc[user_idx, idx]
                if rating > 0:
                    ratings.append(rating)
                    weights.append(sim_scores[idx])

            if len(ratings) == 0 or sum(weights) == 0:
                return self.global_mean

            return np.average(ratings, weights=weights)

        except Exception as e:
            print(f"CF Item-based error: {e}")
            return self.global_mean

# Initialize and compute similarities
cf_model = CollaborativeFiltering(train_matrix)
user_sim = cf_model.compute_user_similarity()
item_sim = cf_model.compute_item_similarity()

# Test before saving
print("\n" + "="*60)
print("TESTING BEFORE SAVING")
print("="*60)
test_user = train_matrix.index[0]
test_movie = train_matrix.columns[100]
print(f"Test: User {test_user}, Movie {test_movie}")
pred_user = cf_model.predict_user_based(test_user, test_movie, k=20)
pred_item = cf_model.predict_item_based(test_user, test_movie, k=20)
print(f"User-based prediction: {pred_user:.2f}")
print(f"Item-based prediction: {pred_item:.2f}")

if pred_user == cf_model.global_mean and pred_item == cf_model.global_mean:
    print("⚠️  WARNING: Both predictions return global mean - check if test user/movie have ratings")

# Save model with explicit similarity matrices
print("\n" + "="*60)
print("SAVING MODEL (NEW FORMAT)")
print("="*60)

cf_data = {
    'user_item_matrix': train_matrix,
    'user_similarity': user_sim,
    'item_similarity': item_sim,
    'global_mean': cf_model.global_mean
}

with open('/content/drive/MyDrive/Recommendation/requirements/cf_model_fixed.pkl', 'wb') as f:
    pickle.dump(cf_data, f)

print("✓ Saved: cf_model_fixed.pkl")

# Test loading
print("\n" + "="*60)
print("TESTING LOAD")
print("="*60)

with open('/content/drive/MyDrive/Recommendation/requirements/cf_model_fixed.pkl', 'rb') as f:
    loaded_data = pickle.load(f)

# Recreate model
cf_test = CollaborativeFiltering(loaded_data['user_item_matrix'])
cf_test.user_similarity = loaded_data['user_similarity']
cf_test.item_similarity = loaded_data['item_similarity']
cf_test.global_mean = loaded_data['global_mean']

print("Testing loaded model...")
pred_user_test = cf_test.predict_user_based(test_user, test_movie, k=20)
pred_item_test = cf_test.predict_item_based(test_user, test_movie, k=20)
print(f"User-based prediction: {pred_user_test:.2f}")
print(f"Item-based prediction: {pred_item_test:.2f}")

if pred_user_test == pred_user and pred_item_test == pred_item:
    print("✅ Model saves and loads correctly!")
else:
    print("❌ Model predictions changed after loading!")

print("\n✓ CF model fixed and saved")